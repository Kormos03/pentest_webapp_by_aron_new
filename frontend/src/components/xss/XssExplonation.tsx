import XssComment from "./XssComment_dom-based";
import { XssPost } from "./XssPost_stored";
import XssSeachBar from "./XssSearchBar_reflected";

export function XssExplonation(){
    return<>
     <h1>What is Cross-Site Scripting (XSS)?</h1>
    <p>
        Cross-Site Scripting, commonly known as XSS, is a type of security vulnerability found in web applications.
        It occurs when an attacker is able to inject malicious scripts (usually JavaScript) into webpages that are viewed by other users.
        This type of attack can lead to various harmful outcomes, such as stealing sensitive information, impersonating users, or spreading malware.
    </p>

    <h2>How Does XSS Work?</h2>
    <p>
        Imagine you're visiting a website that displays comments from other users. Normally, these comments are just text.
        However, if the website isn't properly secured, an attacker could enter a comment that includes a script, like this:
    </p>
    <pre>
&lt;script&gt;alert('Hacked!');&lt;/script&gt;
    </pre>
    <p>
        If the website doesn't handle this properly, it might insert that script into the page. When you visit the page and the browser renders the comment,
        it will also run the script. In this case, it would pop up an alert box saying "Hacked!". While this example is harmless, a real attacker might use
        this method to steal your login cookies, allowing them to impersonate you on the website.
    </p>

    <h2 id="stored-xss">Types of XSS</h2>
    <h3>Stored XSS (Persistent XSS):</h3>
    <p>
        The malicious script is stored on the server, usually in a database, and is served to users whenever they request the affected page. <strong>Example:</strong> An attacker posts a comment containing a malicious script on a forum. Every time someone views that comment, the script executes.
    </p>

    <XssPost/>

    <h3>Reflected XSS (Non-Persistent XSS):</h3>
    <p>
        The malicious script is embedded in a URL and is reflected back to the user by the server. It usually requires the victim to click on a specially crafted link. <strong>Example:</strong> An attacker sends you a link to a search page on a website, but the link includes a script. If the website reflects this input directly
        onto the page without sanitizing it, the script executes when you open the link.
    </p>
    <XssSeachBar/>
    <h3>DOM-based XSS:</h3>
    <p>
        This type of XSS happens when the script is executed directly in the browser by manipulating the Document Object Model (DOM) on the client side,
        without any server interaction. <strong>Example:</strong> A website has a search feature that updates the page dynamically without reloading. If this feature uses unsanitized user input
        to update the page content, an attacker can inject a script that will run in the victimâ€™s browser.
    </p>
    <XssComment/>
    <h2>Real-World Implications of XSS</h2>
    <ul>
        <li><strong>Cookie Theft:</strong> An attacker can steal session cookies, which can be used to impersonate the user and take over their account.</li>
        <a href="https://medium.com/@laur.telliskivi/pentesting-basics-cookie-grabber-xss-8b672e4738b2">Cookie theft example</a>
        <li><strong>Keylogging:</strong> Malicious scripts can capture keystrokes on a webpage, stealing passwords and other sensitive information.</li>
        <li><strong>Phishing:</strong> An attacker can create fake login forms on the page, tricking users into entering their credentials.</li>
        <li><strong>Defacing Websites:</strong> Attackers can change the content of the website, potentially causing reputational damage.</li>
    </ul>

    <h2>Preventing XSS</h2>
    <ul>
        <li><strong>Input Validation and Sanitization:</strong> Always validate and sanitize user inputs to remove or encode any potentially dangerous characters (like &lt; and &gt;).</li>
        <li><strong>Output Encoding:</strong> Encode data before displaying it on the page to ensure that the browser interprets it as data rather than executable code.</li>
        <li><strong>Use Security Libraries and Frameworks:</strong> Use libraries or frameworks that automatically handle user input in a safe way, like React in the context of web development, which escapes strings by default.</li>
        <li><strong>Content Security Policy (CSP):</strong> Implement CSP headers to restrict the sources from which your site can load scripts, reducing the risk of XSS.</li>
        <li><strong>Avoid <code>dangerouslySetInnerHTML</code> in React:</strong> In React, avoid using <code>dangerouslySetInnerHTML</code> unless absolutely necessary, and always sanitize the HTML you inject.</li>
    </ul>

    <h2>Conclusion</h2>
    <p>
        XSS is one of the most common and dangerous vulnerabilities in web applications. It takes advantage of the fact that browsers trust the content served by websites,
        allowing malicious scripts to be executed on unsuspecting users' devices. Understanding how XSS works and how to prevent it is essential for anyone involved
        in web development or cybersecurity.
    </p>

    <p>
        Everytime the user tries to insert html tag or javascript through a variable, React will treat as a plaintext perventing any xss attack!
        To achieve xss in react we have to bypass this kind of sanitizing.
    </p>
   
    </>
}